"""

OpenScribe is free and open-source software for the design and simulation of 3D
nanoprinted materials. Please contribute to the development of this software by
reporting bugs, suggesting new features, and submitting pull requests.

3D PRINTED MATERIALS WITH NANOVOXELATED ELASTIC MODULI
Repo: https://github.com/peterlionelnewman/openscribe
Paper doi: ----------------
Paper url: ----------------
Peter L. H. Newman, 2024, (peterlionelnewman @github)

As well, we'd love if you'd cite us if you use our script in any way :-)

Creative Commons Attribution-NonCommercial 4.0 International Public License
github.com/peterlionelnewman/openscribe/LICENSE

--------------------------------------------------------------------------------

This is a specific utility for the stwl2gwl script that renders the unit cells.

All units are in um / microns unless specified elsewhere.

Coordinate system is ZYX except for within the gwl file where it is XYZ.

The part dimensions and that you designed / imported (probably mm) using your
CAD software will be assumed to be um / micron once imported.

"""
# std
from multiprocessing import Pool

# 3rd
import numpy as np
from scipy.interpolate import interp1d

# local
import src.utils as utils

def distance_from_line(p0, p1, p2):
    # to numpy arrays and vectors v1 (p1 - p0) and v2 (p2 - p0)
    p0, p1, p2 = np.array(p0), np.array(p1), np.array(p2)
    v1 = p1 - p0
    v2 = p2 - p0

    # t: projection of the point onto the line
    v1_sq_magnitude = np.dot(v1, v1)
    t = np.sum(v1 * v2, axis=1) / v1_sq_magnitude

    # Determine which points are closest to line segment endpoints or the line itself
    t_outside_0 = t <= 0.0
    t_outside_1 = t >= 1.0
    t_inside = ~(t_outside_0 | t_outside_1)

    distance = np.zeros(p2.shape[0])
    distance[t_outside_0] = np.linalg.norm(p2[t_outside_0] - p0, axis=1)
    distance[t_outside_1] = np.linalg.norm(p2[t_outside_1] - p1, axis=1)
    distance[t_inside] = np.linalg.norm(np.cross(v1, v2[t_inside]), axis=1) / np.sqrt(v1_sq_magnitude)

    return distance


def calc_distance(args):
    p0, p1, p2, dist_threshold, vol = args
    dist = distance_from_line(p0, p1, p2)
    dist = dist.reshape(vol.shape)
    vol[(dist < dist_threshold) & (vol != 1)] = 1
    return vol


def fill_unit_cell_vol(vol, bounds, dist_threshold, lines):
    z, y, x, = np.meshgrid(np.linspace(bounds[0, 0], bounds[1, 0], vol.shape[0]),
                           np.linspace(bounds[0, 1], bounds[1, 1], vol.shape[1]),
                           np.linspace(bounds[0, 2], bounds[1, 2], vol.shape[2]),
                           indexing='ij')

    p2 = np.vstack([x.ravel(), y.ravel(), z.ravel()]).T
    args = [(p0, p1, p2, dist_threshold, vol) for (p0, p1) in lines]

    with Pool() as pool:
        results = pool.map(calc_distance, args)

    # Combine results
    for result in results:
        vol |= result

    return vol


def from_math(unit_cell_type, period, fill, resolution, inverse):

    if fill == 1.0 and inverse or unit_cell_type == 'none':
        print('Unit_cell_fill==1.0 & Unit_cell_inverse==True,'
          '... fill==0.0 skipping')
        return False

    if unit_cell_type == 'gyroid':

        z = np.arange(0, period, resolution[0])
        y = np.arange(0, period, resolution[1])
        x = np.arange(0, period, resolution[2])

        z, y, x = np.meshgrid(z, y, x, indexing='ij')

        fill_look_up_x = np.array([0., 0.01010101, 0.02020202, 0.03030303, 0.04040404,
                   0.05050505, 0.06060606, 0.07070707, 0.08080808, 0.09090909,
                   0.1010101, 0.11111111, 0.12121212, 0.13131313, 0.14141414,
                   0.15151515, 0.16161616, 0.17171717, 0.18181818, 0.19191919,
                   0.2020202, 0.21212121, 0.22222222, 0.23232323, 0.24242424,
                   0.25252525, 0.26262626, 0.27272727, 0.28282828, 0.29292929,
                   0.3030303, 0.31313131, 0.32323232, 0.33333333, 0.34343434,
                   0.35353535, 0.36363636, 0.37373737, 0.38383838, 0.39393939,
                   0.4040404, 0.41414141, 0.42424242, 0.43434343, 0.44444444,
                   0.45454545, 0.46464646, 0.47474747, 0.48484848, 0.49494949,
                   0.50505051, 0.51515152, 0.52525253, 0.53535354, 0.54545455,
                   0.55555556, 0.56565657, 0.57575758, 0.58585859, 0.5959596,
                   0.60606061, 0.61616162, 0.62626263, 0.63636364, 0.64646465,
                   0.65656566, 0.66666667, 0.67676768, 0.68686869, 0.6969697,
                   0.70707071, 0.71717172, 0.72727273, 0.73737374, 0.74747475,
                   0.75757576, 0.76767677, 0.77777778, 0.78787879, 0.7979798,
                   0.80808081, 0.81818182, 0.82828283, 0.83838384, 0.84848485,
                   0.85858586, 0.86868687, 0.87878788, 0.88888889, 0.8989899,
                   0.90909091, 0.91919192, 0.92929293, 0.93939394, 0.94949495,
                   0.95959596, 0.96969697, 0.97979798, 0.98989899, 1.])
        fill_look_up_y = np.array([0., 0., 0., 0.00548697, 0.00548697,
                   0.02194787, 0.03017833, 0.04663923, 0.04663923, 0.07270233,
                   0.08093278, 0.09327846, 0.09327846, 0.10562414, 0.1303155,
                   0.13854595, 0.15089163, 0.17146776, 0.17146776, 0.17558299,
                   0.18930041, 0.20576132, 0.21399177, 0.218107, 0.24691358,
                   0.24691358, 0.26337449, 0.26337449, 0.27572016, 0.29218107,
                   0.2962963, 0.30041152, 0.30864198, 0.33333333, 0.34705075,
                   0.35939643, 0.36762689, 0.36762689, 0.38820302, 0.39231824,
                   0.4005487, 0.40877915, 0.4170096, 0.43758573, 0.43758573,
                   0.46227709, 0.47050754, 0.48285322, 0.48696845, 0.49931413,
                   0.50068587, 0.51303155, 0.51714678, 0.52949246, 0.53772291,
                   0.56241427, 0.56241427, 0.5829904, 0.59122085, 0.5994513,
                   0.60768176, 0.61179698, 0.63237311, 0.63237311, 0.64060357,
                   0.65294925, 0.66666667, 0.69135802, 0.69958848, 0.7037037,
                   0.70781893, 0.72427984, 0.73662551, 0.73662551, 0.75308642,
                   0.75308642, 0.781893, 0.78600823, 0.79423868, 0.81069959,
                   0.82441701, 0.82853224, 0.82853224, 0.84910837, 0.86145405,
                   0.8696845, 0.89437586, 0.90672154, 0.90672154, 0.91906722,
                   0.92729767, 0.95336077, 0.95336077, 0.96982167, 0.97805213,
                   0.99451303, 0.99451303, 1., 1., 1.])
        dist_threshold = period * interp1d(fill_look_up_y, fill_look_up_x)(fill)

        vol = \
            + np.sin((2 * np.pi / period) * x) * np.cos((2 * np.pi / period) * y) \
            + np.sin((2 * np.pi / period) * y) * np.cos((2 * np.pi / period) * z) \
            + np.sin((2 * np.pi / period) * z) * np.cos((2 * np.pi / period) * x)
        vol = (vol + np.pi / 2) / np.pi
        vol = vol < dist_threshold / period
        bounds = np.array([[0.0, 0.0, 0.0], [period, period, period]])

    elif unit_cell_type == 'cubic':

        p0 = np.array([0.5, 0.5, 0.5]) * period
        p1 = np.array([1.0, 0.5, 0.5]) * period
        p2 = np.array([0.5, 1.0, 0.5]) * period
        p3 = np.array([0.5, 0.5, 1.0]) * period
        p4 = np.array([0.0, 0.5, 0.5]) * period
        p5 = np.array([0.5, 0.0, 0.5]) * period
        p6 = np.array([0.5, 0.5, 0.0]) * period

        fill_look_up_x = np.array([0., 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1,
                   0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.2, 0.21,
                   0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3, 0.31, 0.32,
                   0.33, 0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4, 0.41, 0.42, 0.43,
                   0.44, 0.45, 0.46, 0.47, 0.48, 0.49, 0.5, 0.51, 0.52, 0.53, 0.54,
                   0.55, 0.56, 0.57, 0.58, 0.59, 0.6, 0.61, 0.62, 0.63, 0.64, 0.65,
                   0.66, 0.67, 0.68, 0.69, 0.7, 0.71, 0.72, 0.73, 0.74, 0.75, 0.76,
                   0.77, 0.78, 0.79, 0.8, 0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87,
                   0.88, 0.89, 0.9, 0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98,
                   0.99])
        fill_look_up_y = np.array([0., 0.00145953, 0.00432373, 0.0085487, 0.01547325,
                   0.02093827, 0.03029904, 0.04076818, 0.05490261, 0.0686749,
                   0.08335802, 0.09657064, 0.11422771, 0.13272977, 0.14962963,
                   0.16934979, 0.19191221, 0.21391495, 0.23620302, 0.2588642,
                   0.28317147, 0.30743484, 0.33032647, 0.35172565, 0.3803786,
                   0.40606859, 0.43020027, 0.45589026, 0.48559671, 0.5101893,
                   0.53459534, 0.55959396, 0.58369273, 0.61046914, 0.63519342,
                   0.6598299, 0.68535528, 0.70813717, 0.73093004, 0.75392044,
                   0.77587929, 0.79324005, 0.81388203, 0.83539095, 0.85314678,
                   0.86911385, 0.88486145, 0.90060905, 0.91417284, 0.92494925,
                   0.93485871, 0.94570096, 0.95394239, 0.96095473, 0.96656241,
                   0.97296022, 0.97799726, 0.98192593, 0.98522908, 0.98881756,
                   0.99133059, 0.99310837, 0.99499588, 0.99668587, 0.9976406,
                   0.99831001, 0.99911111, 0.99953909, 0.9997476, 0.99987929,
                   0.99998903, 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
                   1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
                      1., 1.])
        dist_threshold = period * interp1d(fill_look_up_y, fill_look_up_x)(fill)

        vol = np.zeros([utils.custom_round_to_int(period / res) for res in resolution]).astype('uint8')
        bounds = np.array([[0.0, 0.0, 0.0], [period, period, period]])
        lines = [(p0, p1), (p0, p2), (p0, p3), (p0, p4), (p0, p5), (p0, p6)]
        vol = fill_unit_cell_vol(vol, bounds, dist_threshold, lines)

    elif unit_cell_type == 'octet_truss' \
            or unit_cell_type == 'octet' \
            or unit_cell_type == 'octet truss':

        # Define the lines forming the octet truss unit cell
        p_center = (period / 2, period / 2, period / 2)
        p_corners = [(x * period, y * period, z * period) for x in (0, 1) for y in (0, 1) for z in (0, 1)]

        fill_look_up_x = np.array([0., 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1,
                   0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.2, 0.21,
                   0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3, 0.31, 0.32,
                   0.33, 0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4, 0.41, 0.42, 0.43,
                   0.44, 0.45, 0.46, 0.47, 0.48, 0.49, 0.5, 0.51, 0.52, 0.53, 0.54,
                   0.55, 0.56, 0.57, 0.58, 0.59, 0.6, 0.61, 0.62, 0.63, 0.64, 0.65,
                   0.66, 0.67, 0.68, 0.69, 0.7, 0.71, 0.72, 0.73, 0.74, 0.75, 0.76,
                   0.77, 0.78, 0.79, 0.8, 0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87,
                   0.88, 0.89, 0.9, 0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98,
                   0.99])
        fill_look_up_y = np.array([0., 0.00339095, 0.0090535, 0.01734979, 0.03341564,
                   0.04902058, 0.06673251, 0.09129218, 0.11960494, 0.1447572,
                   0.1757037, 0.20348971, 0.24246914, 0.27802469, 0.31397531,
                   0.34676543, 0.39173663, 0.43315226, 0.46785185, 0.50847737,
                   0.55068313, 0.5880823, 0.62482305, 0.66432922, 0.70357202,
                   0.74136626, 0.77165432, 0.80220576, 0.83973663, 0.86798354,
                   0.89241152, 0.91670782, 0.9385679, 0.95529218, 0.97188477,
                   0.98241975, 0.99045267, 0.99499588, 0.99776132, 0.99940741,
                   0.99993416, 1., 1., 1., 1.,1., 1., 1., 1., 1., 1., 1., 1.,
                   1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0.,
                   0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
                   0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
                   0., 0.])
        dist_threshold = period * interp1d(fill_look_up_y, fill_look_up_x)(fill)

        vol = np.zeros([utils.custom_round_to_int(period / res) for res in resolution]).astype('uint8')
        bounds = np.array([[0.0, 0.0, 0.0], [period, period, period]])
        lines = [(p_center, p_corner) for p_corner in p_corners]
        vol = fill_unit_cell_vol(vol, bounds, dist_threshold, lines)

    elif unit_cell_type == 'kelvin_foam'\
            or unit_cell_type == 'kelvin' \
            or unit_cell_type == 'kelvin foam' :

        vertices = np.array([[0.5, 0, 0.75], [0.25, 0, 0.5], [0, 0.25, 0.5],
            [0.75, 0, 0.5], [0, 0.5, 0.75], [0.5, 0, 0.25], [0, 0.75, 0.5],
            [0.5, 0.25, 0], [0.25, 0.5, 0], [0, 0.5, 0.25], [0.5, 0.75, 0],
            [0.75, 0.5, 0], [0.5, 1, 0.75], [0.25, 1, 0.5], [1, 0.25, 0.5],
            [0.75, 1, 0.5], [1, 0.5, 0.75], [0.5, 1, 0.25], [1, 0.75, 0.5],
            [0.5, 0.25, 1], [0.25, 0.5, 1], [1, 0.5, 0.25], [0.5, 0.75, 1],
            [0.75, 0.5, 1]])

        # loop through points, if distance between them is < 0.5, add stack array of point indices
        edges = np.array([[i, j] for i in range(len(vertices))
                          for j in range(i + 1, len(vertices))
                          if np.linalg.norm(vertices[i] - vertices[j]) < 0.5
                          and ((vertices[i] <= 1).all() and (vertices[i] >= 0).all()
                          or ((vertices[j] <= 1).all() and (vertices[j] >= 0).all()))])

        fill_look_up_x = np.array([0., 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1,
                   0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.2, 0.21,
                   0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3, 0.31, 0.32,
                   0.33, 0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4, 0.41, 0.42, 0.43,
                   0.44, 0.45, 0.46, 0.47, 0.48, 0.49, 0.5, 0.51, 0.52, 0.53, 0.54,
                   0.55, 0.56, 0.57, 0.58, 0.59, 0.6, 0.61, 0.62, 0.63, 0.64, 0.65,
                   0.66, 0.67, 0.68, 0.69, 0.7, 0.71, 0.72, 0.73, 0.74, 0.75, 0.76,
                   0.77, 0.78, 0.79, 0.8, 0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87,
                   0.88, 0.89, 0.9, 0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98,
                   0.99])
        fill_look_up_y = np.array([0., 0.00358848, 0.01198354, 0.02479012, 0.04115226,
                   0.06166255, 0.08454321, 0.11394239, 0.14390123, 0.17474897,
                   0.20911934, 0.24622222, 0.28335802, 0.32138272, 0.35802469,
                   0.39865021, 0.43736626, 0.47519342, 0.51084774, 0.54976132,
                   0.58623868, 0.62159671, 0.65402469, 0.68671605, 0.71878189,
                   0.74778601, 0.77501235, 0.80230453, 0.82669959, 0.84852675,
                   0.86893827, 0.88686968, 0.90229904, 0.91592867, 0.92832922,
                   0.93951166, 0.94914678, 0.95716872, 0.96505898, 0.97150069,
                   0.97694376, 0.9816406, 0.98613992, 0.98954184, 0.99202195,
                   0.99418381, 0.99630178, 0.99760768, 0.99840878, 0.99911111,
                   0.99965981, 0.99986831, 0.99997805, 0.99998903, 1.,
                   1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
                   1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
                   1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])
        dist_threshold =  period * interp1d(fill_look_up_y, fill_look_up_x)(fill)

        vol = np.zeros(utils.custom_round_to_int(period / resolution)).astype('uint8')
        bounds = np.array([[0.0, 0.0, 0.0], [period, period, period]])
        vertices = vertices * period
        lines = [(vertices[i], vertices[j]) for i, j in edges]

        vol = fill_unit_cell_vol(vol, bounds, dist_threshold, lines)

    elif unit_cell_type == 'wp' \
            or unit_cell_type == 'wp_foam'\
            or unit_cell_type == 'weaire_phelan' \
            or unit_cell_type == 'weaire_phelan_foam' \
            or unit_cell_type == 'weaire-phelan' \
            or unit_cell_type == 'weaire-phelan_foam' \
            or unit_cell_type == 'weaire-phelan foam':

        vertices = np.array([[1.374833, 0.000542, 0.313036],
            [1.582639, 1.583805, 0.417091], [1.999414, 1.687884, 0.625562],
            [0.999778, 0.000517, 0.500564], [1.686693, 1.374893, 1.999381],
            [1.999036, 0.312928, 0.625224], [0.416118, 1.583554, 0.417247],
            [1.416641, 1.417638, 0.583002], [0.99938, 1.626008, 0.687643],
            [1.374528, 0.000836, 1.688167], [1.582887, 1.582882, 1.583776],
            [1.583228, 0.416633, 0.417188], [0.41566, 0.41717, 0.416774],
            [0.312152, 1.375055, 0.000199], [1.999782, 1.500468, 1.000033],
            [1.625132, 1.312811, 1.000465], [1.31229, 1.000953, 0.374434],
            [0.999015, 1.625244, 1.312907], [0.582337, 1.417418, 0.583502],
            [0.999205, 0.000988, 1.500509], [1.582954, 0.41729, 1.583964],
            [1.499589, 1.000835, 1.999244], [1.687315, 0.625137, 1.999668],
            [0.624322, 0.000725, 0.312769], [0.416475, 1.583942, 1.583184],
            [0.37483, 1.313082, 0.999521], [1.624817, 0.687664, 1.000333],
            [0.686621, 1.000835, 0.374834], [1.416503, 1.416444, 1.417442],
            [0.624634, 0.000964, 1.687531], [1.999937, 1.687755, 1.375079],
            [1.312386, 1.000647, 1.625031], [0.499725, 1.000658, 0.000553],
            [0.31183, 0.624975, 0.000488], [0.375186, 0.688291, 0.999389],
            [1.416715, 0.583171, 0.583818], [0.582556, 0.584101, 0.583805],
            [0.583642, 1.417297, 1.41644], [1.999485, 0.312616, 1.375471],
            [0.416489, 0.416552, 1.584015], [1.999161, 0.500331, 0.999822],
            [0.999925, 0.375397, 0.688204], [0.688262, 1.000529, 1.624602],
            [1.416155, 0.584231, 1.417123], [0.584307, 0.583998, 1.416583],
            [0.999499, 0.37619, 1.313024]]) / 2.0

        # loop through points, if distance between them is < 0.63, add one of
        # the points is within the bounds of the unit cell, add the edge to the
        # list of edges; before doing that tile the points in all directions

        vertices = np.vstack((vertices,
                              vertices + np.array([0, 0, 1]),
                              vertices + np.array([0, 0, -1]),
                              vertices + np.array([0, 1, 0]),
                              vertices + np.array([0, -1, 0]),
                              vertices + np.array([1, 0, 0]),
                              vertices + np.array([-1, 0, 0])))
        edges = np.array([[i, j] for i in range(len(vertices))
                          for j in range(i + 1, len(vertices))
                          if np.linalg.norm(vertices[i] - vertices[j]) < 0.315])
                            # and ((vertices[i] <= 1).all() and (vertices[i] >= 0).all()
                            # or ((vertices[j] <= 1).all() and (vertices[j] >= 0).all()))])

        fill_look_up_x = np.array([0., 0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008,
                   0.009, 0.01 , 0.011, 0.012, 0.013, 0.014, 0.015, 0.016, 0.017,
                   0.018, 0.019, 0.02 , 0.021, 0.022, 0.023, 0.024, 0.025, 0.026,
                   0.027, 0.028, 0.029, 0.03 , 0.031, 0.032, 0.033, 0.034, 0.035,
                   0.036, 0.037, 0.038, 0.039, 0.04 , 0.041, 0.042, 0.043, 0.044,
                   0.045, 0.046, 0.047, 0.048, 0.049, 0.05 , 0.051, 0.052, 0.053,
                   0.054, 0.055, 0.056, 0.057, 0.058, 0.059, 0.06 , 0.061, 0.062,
                   0.063, 0.064, 0.065, 0.066, 0.067, 0.068, 0.069, 0.07 , 0.071,
                   0.072, 0.073, 0.074, 0.075, 0.076, 0.077, 0.078, 0.079, 0.08 ,
                   0.081, 0.082, 0.083, 0.084, 0.085, 0.086, 0.087, 0.088, 0.089,
                   0.09 , 0.091, 0.092, 0.093, 0.094, 0.095, 0.096, 0.097, 0.098,
                   0.099, 0.100, 0.101, 0.102, 0.103, 0.104, 0.105, 0.106, 0.107,
                   0.108, 0.109, 0.11 , 0.111, 0.112, 0.113, 0.114, 0.115, 0.116,
                   0.117, 0.118, 0.119, 0.12 , 0.121, 0.122, 0.123, 0.124, 0.125,
                   0.126, 0.127, 0.128, 0.129, 0.13 , 0.133, 0.136, 0.139, 0.142,
                   0.145, 0.148, 0.151, 0.154, 0.157, 0.16 , 0.163, 0.166, 0.169,
                   0.172, 0.175, 0.178, 0.181, 0.184, 0.187, 0.19 , 0.193, 0.196,
                   0.199, 0.2  , 0.203, 0.206, 0.209, 0.212, 0.215, 0.218, 0.221,
                   0.224, 0.227, 0.23 , 0.233, 0.236, 0.239, 0.242, 0.245, 0.248,
                   0.251, 0.254, 0.257, 0.26 , 0.263, 0.266, 0.269, 0.272, 0.275,
                   0.278, 0.281, 0.284, 0.287, 0.29 , 0.293, 0.296, 0.299, 0.3 ,
                                   0.31, 0.32, 0.33, 0.34, 1.0])
        fill_look_up_y = np.array([0., 0.008448, 0.008448, 0.008448, 0.008448, 0.008448,
                   0.008448, 0.008448, 0.008448, 0.008448, 0.008448, 0.008448,
                   0.008448, 0.008448, 0.008448, 0.008448, 0.008448, 0.008448,
                   0.008448, 0.014336, 0.01632 , 0.036288, 0.039296, 0.0448  ,
                   0.045568, 0.045568, 0.045568, 0.045568, 0.045568, 0.045568,
                   0.045568, 0.045568, 0.045568, 0.045568, 0.051584, 0.057856,
                   0.057856, 0.059456, 0.07776 , 0.077952, 0.077952, 0.089024,
                   0.093248, 0.093696, 0.093696, 0.099712, 0.107648, 0.120384,
                   0.121088, 0.121088, 0.121088, 0.121088, 0.124352, 0.133632,
                   0.133632, 0.133632, 0.148992, 0.159744, 0.1616  , 0.171904,
                   0.173568, 0.17984 , 0.185984, 0.193984, 0.194816, 0.194816,
                   0.194816, 0.199104, 0.204352, 0.209152, 0.216448, 0.217664,
                   0.228672, 0.22912 , 0.22912 , 0.24448 , 0.26624 , 0.26688 ,
                   0.26688 , 0.26688 , 0.276608, 0.280192, 0.290944, 0.291648,
                   0.2944  , 0.296256, 0.324608, 0.330368, 0.330368, 0.33184 ,
                   0.335744, 0.3392  , 0.348224, 0.350784, 0.3584  , 0.359936,
                   0.378944, 0.379392, 0.379392, 0.379392, 0.380672, 0.387136,
                   0.410176, 0.417536, 0.423872, 0.443712, 0.443904, 0.443904,
                   0.443904, 0.444608, 0.444672, 0.445888, 0.471296, 0.494272,
                   0.494464, 0.495104, 0.503744, 0.51136 , 0.512384, 0.513792,
                   0.526912, 0.52736 , 0.531072, 0.534528, 0.545984, 0.550528,
                   0.552704, 0.559104, 0.560768, 0.560768, 0.589775, 0.6072  ,
                   0.6209  , 0.636625, 0.64905 , 0.667125, 0.686225, 0.699675,
                   0.714675, 0.72955 , 0.74315 , 0.755975, 0.76905 , 0.78295 ,
                   0.79625 , 0.806525, 0.81915 , 0.828275, 0.836125, 0.8464  ,
                   0.85975 , 0.8673  , 0.8759  , 0.883   , 0.8863  , 0.896775,
                   0.903325, 0.909375, 0.9157  , 0.9218  , 0.92775 , 0.932725,
                   0.938   , 0.943775, 0.947675, 0.952125, 0.957   , 0.9608  ,
                   0.9645  , 0.96685 , 0.9693  , 0.974225, 0.9775  , 0.9796  ,
                   0.981375, 0.982925, 0.9845  , 0.9861  , 0.988775, 0.991625,
                   0.99195 , 0.9931  , 0.993775, 0.9947  , 0.9961  , 0.9967  ,
                   0.9973  , 0.99805, 0.99825, 0.9991 , 0.9999 , 0.99995, 1. ,
                   1.0])

        if len(fill_look_up_x) != len(fill_look_up_y):
            raise ValueError('fill_look_up_x and fill_look_up_y must have the same length')

        period *= 2.0
        bounds = np.array([[0.0, 0.0, 0.0], [period, period, period]])
        vertices = vertices * period
        lines = [(vertices[i], vertices[j]) for i, j in edges]
        dist_threshold = period * interp1d(fill_look_up_y, fill_look_up_x)(fill)
        vol = np.zeros(utils.custom_round_to_int(period / resolution)).astype('uint8')
        vol = fill_unit_cell_vol(vol, bounds, dist_threshold, lines)

    else:
        raise ValueError("unit_cell_type not supported")

    # TO BE: added later maybe -> by special request
    #   schwartz_primative, schwartz_diamond, voroni, schoen_gyroid, schoen_iwp,
    #   split_p, fischer_koch, neovius, lidinoid

    vol = vol > 0

    if inverse:
        vol = ~vol

    # check bounds[1, :] are all equal
    if not np.all(bounds[1, :] == bounds[1, 0]):
        raise ValueError("bounds[1, :] must be equal")

    # plotter.plot_boolean(vol)

    return vol
